<div class="wikidoc"><h1>Live Geometry Documentation</h1>
<h2>Links:</h2><ol><li><a href="https://livegeometry.codeplex.com/wikipage?title=Contributing&referringTitle=Documentation">Contributing</a> - contributing to the project, working with source control</li>
<li><a href="https://livegeometry.codeplex.com/wikipage?title=CodingGuidelines&referringTitle=Documentation">CodingGuidelines</a> - the project&#39;s coding guidelines</li></ol>

<h2>Requirements</h2>The project is built using Visual Studio 2008 with Silverlight Tools installed (currently Silverlight 3.0). The language is C# 3.0, and the projects exist that target both WPF (.NET Framework 3.5) and Silverlight 3.0. Same source code files are used for WPF and Silverlight versions.<br />
<h2>Source code overview</h2>
The source code (<a href="http://livegeometry.codeplex.com/SourceControl/changeset/view/23690">Main</a>) consists of several projects:
<ul><li><b>DynamicGeometryLibrary</b></li></ul>
The dynamic geometry library (framework) that provides types and services to model geometric figures and drawings.<br />DynamicGeometry.csproj is the WPF (desktop) project, and SilverlightDynamicGeometry.csproj is the Silverlight project. They both reference the same set of .cs files.
<ul><li><b>SilverlightClient</b></li></ul>
Silverlight client application (front-end) for the Dynamic Geometry library.
<ul><li><b>WPFClient</b></li></ul>
WPF (desktop) version. It is currently less maintained and I concentrate more efforts on the Silverlight version. It doesn&#39;t expose all the feature that are available in the DynamicGeometryLibrary yet. I will come back to WPF at a later point and update it to surface more features and to reach parity with Silverlight client.
<ul><li><b>Samples</b></li></ul>
Samples folder currently contains one sample application that is built on top of the dynamic geometry library. It is called PolylineRouting and it is a simple app that connects two dots with the shortest path around a polygon. Read more here: <a href="http://blogs.msdn.com/kirillosenkov/archive/2009/06/07/algorithms-in-c-shortest-path-around-a-polygon-polyline-routing.aspx">http://blogs.msdn.com/kirillosenkov/archive/2009/06/07/algorithms-in-c-shortest-path-around-a-polygon-polyline-routing.aspx</a><br />
<h2>Drawing.cs</h2>
The central class of the DynamicGeometry library is a Drawing. A Drawing represents a set of figures as a logical entity. It&#39;s not a WPF/Silverlight control, so you can&#39;t directly place a Drawing on a Canvas. Instead, you can associate a Drawing with any existing Canvas control. A Drawing HAS a Canvas, not Drawing IS Canvas.<br />A Drawing references several other parts, such as a RootFigureList, an ActionManager, a Behavior, a CoordinateSystem, a CoordinateGrid (CartesianGrid) etc.<br /><br /><img src="http://download-codeplex.sec.s-msft.com/Download?ProjectName=LiveGeometry&DownloadId=71709" alt="Drawing.png" title="Drawing.png" /><br /><br />To experiment with hosting a Drawing on your own Canvas, you can view the PolylineRouting sample: <a href="http://livegeometry.codeplex.com/sourcecontrol/changeset/view/23690?projectName=LiveGeometry#397865">Main\Samples\PolylineRouting\Page.xaml.cs</a><br />
<h2>FigureList.cs</h2>
A FigureList is a list of figures in a Drawing. Actually, Drawing references a derived class called RootFigureList.<br />
<h2>Dependency Tracking</h2>
Dynamic geometry stores an algorithm of a construction, and figure coordinates are recalculated every time a drawing is changed. All the figures are classified into three groups: independent, semi-dependent and dependent.<br />
<ul><li>Figures can be independent of other figures, for instance a point can exist all by itself and its coordinates are determined by the user who drags the point around.</li>
<li>Other figures can be partially dependent on other figures (for example, a point on a line can be both dragged by the user or moved with the line as the line moves around).</li>
<li>Finally, a figure can be fully dependent on other figures. For example, a segment is fully defined by two points, so the user has no way of influencing the segment other than moving its endpoints. A caveat here is that if you drag a dependent figure, the dynamic geometry engine computes the least set of independent figures that fully defines the one the user is dragging, and drags this set, so the user has the impression of dragging the figure itself.</li></ul>

<ul><li>Independent figures are: Point, Label, Hyperlink, FunctionGraph.</li>
<li>Semi-dependent figure is: PointOnFigure.</li>
<li>All other figures are dependent (e.g. Segment, Line, Circle, IntersectionOfCircleAndLine, Polygon, CoordinatesMeasurement, etc.)</li></ul>
<br />A figure can have dependencies (figures it depends on) and dependents (figures that are depending on it). This relationship can be modeled using &quot;in&quot; and &quot;out&quot; edges of a dependency graph. The dependency graph doesn&#39;t have cycles, so it&#39;s really a <a href="http://en.wikipedia.org/wiki/Directed_acyclic_graph">DAG</a>.<br /><br />Since all the figures form a DAG with respect to the dependency relationship, we sort the figures using <a href="http://en.wikipedia.org/wiki/Topological_sorting">topological sorting</a>. Here&#39;s an example of the DAG for a circle circumscribed around a triangle (dependencies are in parentheses):<br /><br /><img src="http://download-codeplex.sec.s-msft.com/Download?ProjectName=LiveGeometry&DownloadId=71727" alt="CircumscribedCircle.PNG" title="CircumscribedCircle.PNG" /><br /><br />1. Point<br />2. Point<br />3. Point<br />4. Segment (1, 2)<br />5. Segment (2, 3)<br />6. Segment (1, 3)<br />7. Midpoint (1, 2)<br />8. Midpoint (1, 3)<br />9. Perpendicular (7, 4)<br />10. Perpendicular (8, 6)<br />11. Intersection (9, 10)<br />12. Circle (11, 1)<br /><br />This is sufficient description to fully define the drawing given the coordinates of the first three points as input. The coordinates of all figures are recalculated every time an independent or semi-dependent figure has been moved by user. Figures are recalculated in topological order (top-to-bottom in our example). Topological order means that all dependencies of each figure come before it (and all dependents come after it). A drawing is usually fully defined by several independent figures (points). <br /><br />Each figure (IFigure) has a property called Dependencies, which is a list of figures that the current figure depends on. Also each figure has a property called Dependents which stores all figures that directly depend on this one. When a new figure is created, a RegisterWithDependencies() method is called, that fills the new figure&#39;s Dependencies list and then goes through all the figures in it and adds the new figure to their Dependents list. So the relationship is bi-directional. <br /><br />The TopologicalSort method is used to sort all figures topologically with regards to the dependency relationship. You can read more at : <br /><a href="http://blogs.msdn.com/kirillosenkov/archive/2008/08/10/representing-dependencies-in-code.aspx">http://blogs.msdn.com/kirillosenkov/archive/2008/08/10/representing-dependencies-in-code.aspx</a><br />
<h2>Function Graphs</h2>
The Silverlight client exposes a feature that allows the user to plot function graphs given a string such as &quot;sin(x)&quot; or &quot;x*2 + 3&quot;. To evaluate arithmetical expression, we host the DLR and piggyback on its ability to compile a string to an executable delegate. Read more at: <br /><a href="http://blogs.msdn.com/kirillosenkov/archive/2009/03/26/dlr-hosting-in-silverlight.aspx">http://blogs.msdn.com/kirillosenkov/archive/2009/03/26/dlr-hosting-in-silverlight.aspx</a></div><div class="ClearBoth"></div>