//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 10.0
//

using HalconDotNet;

public partial class HDevelopExport
{
#if !NO_EXPORT_APP_MAIN
  public HDevelopExport()
  {
    // Default settings used in HDevelop 
    HOperatorSet.SetSystem("do_low_error", "false");
    action();
  }
#endif

  // Procedures 
  // Chapter: Develop
  // Short Description: Open a new graphics window that preserves the aspect ratio of the given image.
  public void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
      HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
  {



    // Local control variables 

    HTuple hv_MinWidth=new HTuple(), hv_MaxWidth=new HTuple();
    HTuple hv_MinHeight=new HTuple(), hv_MaxHeight=new HTuple();
    HTuple hv_ResizeFactor, hv_ImageWidth, hv_ImageHeight;
    HTuple hv_TempWidth, hv_TempHeight, hv_WindowWidth, hv_WindowHeight;

    // Initialize local and output iconic variables 

    //This procedure opens a new graphics window and adjusts the size
    //such that it fits into the limits specified by WidthLimit
    //and HeightLimit, but also maintains the correct image aspect ratio.
    //
    //If it is impossible to match the minimum and maximum extent requirements
    //at the same time (f.e. if the image is very long but narrow),
    //the maximum value gets a higher priority,
    //
    //Parse input tuple WidthLimit
    if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
    {
      hv_MinWidth = 500;
      hv_MaxWidth = 800;
    }
    else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinWidth = 0;
      hv_MaxWidth = hv_WidthLimit.Clone();
    }
    else
    {
      hv_MinWidth = hv_WidthLimit[0];
      hv_MaxWidth = hv_WidthLimit[1];
    }
    //Parse input tuple HeightLimit
    if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
    {
      hv_MinHeight = 400;
      hv_MaxHeight = 600;
    }
    else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinHeight = 0;
      hv_MaxHeight = hv_HeightLimit.Clone();
    }
    else
    {
      hv_MinHeight = hv_HeightLimit[0];
      hv_MaxHeight = hv_HeightLimit[1];
    }
    //
    //Test, if window size has to be changed.
    hv_ResizeFactor = 1;
    HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
    //First, expand window to the minimum extents (if necessary).
    if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_ImageWidth))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
        hv_ImageHeight)))) != 0)
    {
      hv_ResizeFactor = (((((hv_MinWidth.TupleReal())/hv_ImageWidth)).TupleConcat(
          (hv_MinHeight.TupleReal())/hv_ImageHeight))).TupleMax();
    }
    hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
    hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
    //Then, shrink window to maximum extents (if necessary).
    if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
        hv_TempHeight)))) != 0)
    {
      hv_ResizeFactor = hv_ResizeFactor*((((((hv_MaxWidth.TupleReal())/hv_TempWidth)).TupleConcat(
          (hv_MaxHeight.TupleReal())/hv_TempHeight))).TupleMin());
    }
    hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
    hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
    //Resize window
    HOperatorSet.SetWindowAttr("background_color","black");
    HOperatorSet.OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"","",out hv_WindowHandle);
    HDevWindowStack.Push(hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_ImageHeight-1, hv_ImageWidth-1);
    }

    return;
  }

  // Main procedure 
  private void action()
  {

    // Local iconic variables 

    HObject ho_Image1, ho_Rectangle, ho_ImageReduced;
    HObject ho_Regions, ho_ConnectedRegions, ho_SelectedRegions;
    HObject ho_SelectedRegions1, ho_SortedRegions, ho_RegionTrans;
    HObject ho_Rectangle1=null;


    // Local control variables 

    HTuple hv_WindowHandle, hv_Row4, hv_Column4;
    HTuple hv_Area, hv_Row, hv_Column, hv_Phi, hv_Row3, hv_Column3;
    HTuple hv_Phi1, hv_Length1, hv_Length2, hv_PhiSum, hv_Index1;
    HTuple hv_L2Mean, hv_L1Mean, hv_PhiMean, hv_DeltaRow, hv_DeltaCol;
    HTuple hv_NewRow, hv_NewCol, hv_Index;

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image1);
    HOperatorSet.GenEmptyObj(out ho_Rectangle);
    HOperatorSet.GenEmptyObj(out ho_ImageReduced);
    HOperatorSet.GenEmptyObj(out ho_Regions);
    HOperatorSet.GenEmptyObj(out ho_ConnectedRegions);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegions);
    HOperatorSet.GenEmptyObj(out ho_SelectedRegions1);
    HOperatorSet.GenEmptyObj(out ho_SortedRegions);
    HOperatorSet.GenEmptyObj(out ho_RegionTrans);
    HOperatorSet.GenEmptyObj(out ho_Rectangle1);


    ho_Image1.Dispose();
    HOperatorSet.ReadImage(out ho_Image1, "C:/Users/GPAP/Desktop/2.jpg");
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.CloseWindow(HDevWindowStack.Pop());
    }
    dev_open_window_fit_image(ho_Image1, 0, 0, -1, -1, out hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispObj(ho_Image1, HDevWindowStack.GetActive());
    }
    //draw_rectangle1 (WindowHandle, Row1, Column1, Row2, Column2)
    HOperatorSet.DrawPointMod(hv_WindowHandle, 100, 100, out hv_Row4, out hv_Column4);


    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
    }
    ho_Rectangle.Dispose();
    HOperatorSet.GenRectangle1(out ho_Rectangle, hv_Row4-134, hv_Column4-1349, hv_Row4+62, 
        hv_Column4-379);
    ho_ImageReduced.Dispose();
    HOperatorSet.ReduceDomain(ho_Image1, ho_Rectangle, out ho_ImageReduced);
    ho_Regions.Dispose();
    HOperatorSet.Threshold(ho_ImageReduced, out ho_Regions, 0, 20);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "fill");
    }
    ho_ConnectedRegions.Dispose();
    HOperatorSet.Connection(ho_Regions, out ho_ConnectedRegions);
    ho_SelectedRegions.Dispose();
    HOperatorSet.SelectShape(ho_ConnectedRegions, out ho_SelectedRegions, "area", 
        "and", 2201.39, 4500);
    ho_SelectedRegions1.Dispose();
    HOperatorSet.SelectShape(ho_SelectedRegions, out ho_SelectedRegions1, "height", 
        "and", 20, 79.94);
    ho_SortedRegions.Dispose();
    HOperatorSet.SortRegion(ho_SelectedRegions1, out ho_SortedRegions, "character", 
        "true", "row");


    ho_RegionTrans.Dispose();
    HOperatorSet.ShapeTrans(ho_SelectedRegions1, out ho_RegionTrans, "rectangle2");
    HOperatorSet.AreaCenter(ho_RegionTrans, out hv_Area, out hv_Row, out hv_Column);
    HOperatorSet.OrientationRegion(ho_RegionTrans, out hv_Phi);
    HOperatorSet.SmallestRectangle2(ho_RegionTrans, out hv_Row3, out hv_Column3, 
        out hv_Phi1, out hv_Length1, out hv_Length2);
    hv_PhiSum = 0;
    for (hv_Index1=1; (int)hv_Index1<=(int)(new HTuple(hv_Phi1.TupleLength())); hv_Index1 = (int)hv_Index1 + 1)
    {
      if ((int)(new HTuple(((hv_Phi1.TupleSelect(hv_Index1-1))).TupleLess(0))) != 0)
      {
        hv_Phi1[hv_Index1-1] = (hv_Phi1.TupleSelect(hv_Index1-1))+((new HTuple(90)).TupleRad()
            );
      }
      hv_PhiSum = hv_PhiSum+(hv_Phi1.TupleSelect(hv_Index1-1));
    }

    HOperatorSet.TupleMean(hv_Length2, out hv_L2Mean);
    HOperatorSet.TupleMean(hv_Length1, out hv_L1Mean);
    hv_PhiMean = hv_PhiSum/(new HTuple(hv_Phi1.TupleLength()));




    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetColor(HDevWindowStack.GetActive(), "red");
    }

    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispObj(ho_Image1, HDevWindowStack.GetActive());
    }
    if (HDevWindowStack.IsOpen())
    {
      //dev_display (RegionTrans)
    }
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetColor(HDevWindowStack.GetActive(), "green");
    }
    //disp_cross (WindowHandle, Row, Column, 86, 0)
    //disp_line (WindowHandle, Row[2], Column[2], Row[0], Column[0])

    hv_DeltaRow = ((hv_Row.TupleSelect(2))-(hv_Row.TupleSelect(0)))/4;
    hv_DeltaCol = ((hv_Column.TupleSelect(2))-(hv_Column.TupleSelect(0)))/4;

    hv_NewRow = (hv_Row.TupleSelect(2))+hv_DeltaRow;
    hv_NewCol = (hv_Column.TupleSelect(2))+hv_DeltaCol;
    for (hv_Index=1; (int)hv_Index<=4; hv_Index = (int)hv_Index + 1)
    {
      if (HDevWindowStack.IsOpen())
      {
        //dev_set_draw ('fill')
      }
      //gen_rectangle2 (Rectangle1, NewRow-2*(Index-1)*DeltaRow, NewCol-2*(Index-1)*DeltaCol, PhiMean, L1Mean, 700)
      if (HDevWindowStack.IsOpen())
      {
        HOperatorSet.SetDraw(HDevWindowStack.GetActive(), "margin");
      }
      ho_Rectangle1.Dispose();
      HOperatorSet.GenRectangle2(out ho_Rectangle1, hv_NewRow-((2*(hv_Index-1))*hv_DeltaRow), 
          hv_NewCol-((2*(hv_Index-1))*hv_DeltaCol), hv_PhiMean, hv_L1Mean-60, 1000);

    }




































    ho_Image1.Dispose();
    ho_Rectangle.Dispose();
    ho_ImageReduced.Dispose();
    ho_Regions.Dispose();
    ho_ConnectedRegions.Dispose();
    ho_SelectedRegions.Dispose();
    ho_SelectedRegions1.Dispose();
    ho_SortedRegions.Dispose();
    ho_RegionTrans.Dispose();
    ho_Rectangle1.Dispose();

  }


}
#if !NO_EXPORT_APP_MAIN
public class HDevelopExportApp
{
  static void Main(string[] args)
  {
    new HDevelopExport();
  }
}
#endif

