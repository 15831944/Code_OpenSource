//
//  File generated by HDevelop for HALCON/DOTNET (C#) Version 10.0
//

using HalconDotNet;

public partial class HDevelopExport
{
#if !NO_EXPORT_APP_MAIN
  public HDevelopExport()
  {
    // Default settings used in HDevelop 
    HOperatorSet.SetSystem("do_low_error", "false");
    action();
  }
#endif

  // Procedures 
  // Chapter: Develop
  // Short Description: Open a new graphics window that preserves the aspect ratio of the given image.
  public void dev_open_window_fit_image (HObject ho_Image, HTuple hv_Row, HTuple hv_Column, 
      HTuple hv_WidthLimit, HTuple hv_HeightLimit, out HTuple hv_WindowHandle)
  {



    // Local control variables 

    HTuple hv_MinWidth=new HTuple(), hv_MaxWidth=new HTuple();
    HTuple hv_MinHeight=new HTuple(), hv_MaxHeight=new HTuple();
    HTuple hv_ResizeFactor, hv_ImageWidth, hv_ImageHeight;
    HTuple hv_TempWidth, hv_TempHeight, hv_WindowWidth, hv_WindowHeight;

    // Initialize local and output iconic variables 

    //This procedure opens a new graphics window and adjusts the size
    //such that it fits into the limits specified by WidthLimit
    //and HeightLimit, but also maintains the correct image aspect ratio.
    //
    //If it is impossible to match the minimum and maximum extent requirements
    //at the same time (f.e. if the image is very long but narrow),
    //the maximum value gets a higher priority,
    //
    //Parse input tuple WidthLimit
    if ((int)((new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_WidthLimit.TupleLess(0)))) != 0)
    {
      hv_MinWidth = 500;
      hv_MaxWidth = 800;
    }
    else if ((int)(new HTuple((new HTuple(hv_WidthLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinWidth = 0;
      hv_MaxWidth = hv_WidthLimit.Clone();
    }
    else
    {
      hv_MinWidth = hv_WidthLimit[0];
      hv_MaxWidth = hv_WidthLimit[1];
    }
    //Parse input tuple HeightLimit
    if ((int)((new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(0))).TupleOr(
        new HTuple(hv_HeightLimit.TupleLess(0)))) != 0)
    {
      hv_MinHeight = 400;
      hv_MaxHeight = 600;
    }
    else if ((int)(new HTuple((new HTuple(hv_HeightLimit.TupleLength())).TupleEqual(
        1))) != 0)
    {
      hv_MinHeight = 0;
      hv_MaxHeight = hv_HeightLimit.Clone();
    }
    else
    {
      hv_MinHeight = hv_HeightLimit[0];
      hv_MaxHeight = hv_HeightLimit[1];
    }
    //
    //Test, if window size has to be changed.
    hv_ResizeFactor = 1;
    HOperatorSet.GetImageSize(ho_Image, out hv_ImageWidth, out hv_ImageHeight);
    //First, expand window to the minimum extents (if necessary).
    if ((int)((new HTuple(hv_MinWidth.TupleGreater(hv_ImageWidth))).TupleOr(new HTuple(hv_MinHeight.TupleGreater(
        hv_ImageHeight)))) != 0)
    {
      hv_ResizeFactor = (((((hv_MinWidth.TupleReal())/hv_ImageWidth)).TupleConcat(
          (hv_MinHeight.TupleReal())/hv_ImageHeight))).TupleMax();
    }
    hv_TempWidth = hv_ImageWidth*hv_ResizeFactor;
    hv_TempHeight = hv_ImageHeight*hv_ResizeFactor;
    //Then, shrink window to maximum extents (if necessary).
    if ((int)((new HTuple(hv_MaxWidth.TupleLess(hv_TempWidth))).TupleOr(new HTuple(hv_MaxHeight.TupleLess(
        hv_TempHeight)))) != 0)
    {
      hv_ResizeFactor = hv_ResizeFactor*((((((hv_MaxWidth.TupleReal())/hv_TempWidth)).TupleConcat(
          (hv_MaxHeight.TupleReal())/hv_TempHeight))).TupleMin());
    }
    hv_WindowWidth = hv_ImageWidth*hv_ResizeFactor;
    hv_WindowHeight = hv_ImageHeight*hv_ResizeFactor;
    //Resize window
    HOperatorSet.SetWindowAttr("background_color","black");
    HOperatorSet.OpenWindow(hv_Row,hv_Column,hv_WindowWidth,hv_WindowHeight,0,"","",out hv_WindowHandle);
    HDevWindowStack.Push(hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetPart(HDevWindowStack.GetActive(), 0, 0, hv_ImageHeight-1, hv_ImageWidth-1);
    }

    return;
  }

  // Local procedures 
  public void GetVerticalFromDistance (HTuple hv_FootRow, HTuple hv_FootCol, HTuple hv_LineRowStart, 
      HTuple hv_LineColStart, HTuple hv_LineRowEnd, HTuple hv_LineColEnd, HTuple hv_Distance, 
      HTuple hv_Direction, HTuple hv_Polarity, out HTuple hv_TargetRow, out HTuple hv_TargetCol, 
      out HTuple hv_k, out HTuple hv_b, out HTuple hv_kIn, out HTuple hv_bIn)
  {


    // Local control variables 

    HTuple hv_RealDeltaCol, hv_RealDeltaRow, hv_Sqrt;
    HTuple hv_row1, hv_col1, hv_row2, hv_col2, hv_TargetCo1=new HTuple();

    // Initialize local and output iconic variables 

    hv_TargetRow = new HTuple();
    hv_TargetCol = new HTuple();
    HOperatorSet.TupleReal(hv_LineColEnd-hv_LineColStart, out hv_RealDeltaCol);
    HOperatorSet.TupleReal(hv_LineRowEnd-hv_LineRowStart, out hv_RealDeltaRow);

    hv_kIn = hv_RealDeltaCol/hv_RealDeltaRow;
    hv_bIn = hv_FootCol-(hv_kIn*hv_FootRow);

    hv_k = -1/hv_kIn;
    hv_b = ((hv_FootRow*hv_kIn)+hv_bIn)-(hv_k*hv_FootRow);

    //找出目标点
    HOperatorSet.TupleSqrt((hv_Distance*hv_Distance)/((hv_k*hv_k)+1), out hv_Sqrt);
    hv_row1 = hv_Sqrt+hv_FootRow;
    hv_col1 = (hv_k*hv_row1)+hv_b;

    hv_row2 = (-hv_Sqrt)+hv_FootRow;
    hv_col2 = (hv_k*hv_row2)+hv_b;

    if ((int)(new HTuple(hv_Direction.TupleEqual("row"))) != 0)
    {
      if ((int)(new HTuple(hv_Polarity.TupleGreaterEqual(0))) != 0)
      {
        hv_TargetRow = hv_row1.Clone();
        hv_TargetCol = hv_col1.Clone();
      }
      else
      {
        hv_TargetRow = hv_row2.Clone();
        hv_TargetCol = hv_col2.Clone();
      }
    }

    if ((int)(new HTuple(hv_Direction.TupleEqual("col"))) != 0)
    {
      if ((int)(new HTuple(hv_Polarity.TupleGreaterEqual(0))) != 0)
      {
        if ((int)(new HTuple(hv_col1.TupleGreaterEqual(hv_FootCol))) != 0)
        {
          hv_TargetCo1 = hv_col1.Clone();
          hv_TargetRow = hv_row1.Clone();
        }
        else
        {
          hv_TargetCo1 = hv_col2.Clone();
          hv_TargetRow = hv_row1.Clone();
        }
      }
      else
      {
        if ((int)(new HTuple(hv_col1.TupleGreaterEqual(hv_FootCol))) != 0)
        {
          hv_TargetCo1 = hv_col2.Clone();
          hv_TargetRow = hv_row2.Clone();
        }
        else
        {
          hv_TargetCo1 = hv_col1.Clone();
          hv_TargetRow = hv_row1.Clone();
        }
      }
    }


    return;
  }

  public void GetParallelLineFromDistance (HTuple hv_LineInRow, HTuple hv_LineInCol, 
      HTuple hv_LineInRow1, HTuple hv_LineInCol1, HTuple hv_Distance, HTuple hv_Direction, 
      HTuple hv_Polarity, out HTuple hv_LineOutRow, out HTuple hv_LineOutCol, out HTuple hv_LineOutRow1, 
      out HTuple hv_LineOutCol1, out HTuple hv_k, out HTuple hv_b)
  {


    // Local control variables 

    HTuple hv_RealDeltaCol, hv_RealDeltaRow, hv_kIn;
    HTuple hv_bIn, hv_k1, hv_b1, hv_k2, hv_b2, hv_Sqrt1, hv_Sqrt2;
    HTuple hv_row1, hv_col1, hv_rowTemp1, hv_colTemp1, hv_row2;
    HTuple hv_col2, hv_rowTemp2, hv_colTemp2;

    // Initialize local and output iconic variables 

    hv_LineOutRow = new HTuple();
    hv_LineOutCol = new HTuple();
    hv_LineOutRow1 = new HTuple();
    hv_LineOutCol1 = new HTuple();
    HOperatorSet.TupleReal(hv_LineInCol1-hv_LineInCol, out hv_RealDeltaCol);
    HOperatorSet.TupleReal(hv_LineInRow1-hv_LineInRow, out hv_RealDeltaRow);

    hv_kIn = hv_RealDeltaCol/hv_RealDeltaRow;
    hv_bIn = hv_LineInCol-(hv_kIn*hv_LineInRow);
    hv_k = hv_kIn.Clone();
    hv_b = hv_bIn.Clone();


    hv_k1 = -1/hv_kIn;
    hv_b1 = ((hv_LineInRow*hv_kIn)+hv_bIn)-(hv_k1*hv_LineInRow);

    hv_k2 = hv_k1.Clone();
    hv_b2 = ((hv_LineInRow1*hv_kIn)+hv_bIn)-(hv_k2*hv_LineInRow1);

    //找出目标点
    HOperatorSet.TupleSqrt((hv_Distance*hv_Distance)/((hv_k1*hv_k1)+1), out hv_Sqrt1);
    HOperatorSet.TupleSqrt((hv_Distance*hv_Distance)/((hv_k2*hv_k2)+1), out hv_Sqrt2);


    hv_row1 = hv_Sqrt1+hv_LineInRow;
    hv_col1 = (hv_k1*hv_row1)+hv_b1;
    hv_rowTemp1 = hv_Sqrt2+hv_LineInRow1;
    hv_colTemp1 = (hv_k2*hv_rowTemp1)+hv_b2;


    //另一条平行线
    hv_row2 = (-hv_Sqrt1)+hv_LineInRow;
    hv_col2 = (hv_k1*hv_row2)+hv_b1;
    hv_rowTemp2 = (-hv_Sqrt2)+hv_LineInRow1;
    hv_colTemp2 = (hv_k2*hv_rowTemp2)+hv_b2;



    if ((int)(new HTuple(hv_Direction.TupleEqual("row"))) != 0)
    {
      if ((int)(new HTuple(hv_Polarity.TupleGreaterEqual(0))) != 0)
      {
        hv_LineOutRow = hv_row1.Clone();
        hv_LineOutCol = hv_col1.Clone();
        hv_LineOutRow1 = hv_rowTemp1.Clone();
        hv_LineOutCol1 = hv_colTemp1.Clone();

      }
      else
      {
        hv_LineOutRow = hv_row2.Clone();
        hv_LineOutCol = hv_col2.Clone();
        hv_LineOutRow1 = hv_rowTemp2.Clone();
        hv_LineOutCol1 = hv_colTemp2.Clone();
      }
    }

    if ((int)(new HTuple(hv_Direction.TupleEqual("col"))) != 0)
    {
      if ((int)(new HTuple(hv_Polarity.TupleGreaterEqual(0))) != 0)
      {
        if ((int)(new HTuple(hv_col1.TupleGreaterEqual(hv_LineInCol))) != 0)
        {
          hv_LineOutCol = hv_col1.Clone();
          hv_LineOutRow = hv_row1.Clone();
          hv_LineOutRow1 = hv_rowTemp1.Clone();
          hv_LineOutCol1 = hv_colTemp1.Clone();
        }
        else
        {
          hv_LineOutCol = hv_col2.Clone();
          hv_LineOutRow = hv_row2.Clone();
          hv_LineOutRow1 = hv_rowTemp2.Clone();
          hv_LineOutCol1 = hv_colTemp2.Clone();
        }
      }
      else
      {
        if ((int)(new HTuple(hv_col1.TupleGreaterEqual(hv_LineInCol))) != 0)
        {
          hv_LineOutCol = hv_col2.Clone();
          hv_LineOutRow = hv_row2.Clone();
          hv_LineOutRow1 = hv_rowTemp2.Clone();
          hv_LineOutCol1 = hv_colTemp2.Clone();
        }
        else
        {
          hv_LineOutCol = hv_col1.Clone();
          hv_LineOutRow = hv_row1.Clone();
          hv_LineOutRow1 = hv_rowTemp1.Clone();
          hv_LineOutCol1 = hv_colTemp1.Clone();
        }
      }
    }




    return;
  }

  // Main procedure 
  private void action()
  {

    // Local iconic variables 

    HObject ho_Image11515282Cam0;


    // Local control variables 

    HTuple hv_WindowHandle, hv_row, hv_col, hv_row1;
    HTuple hv_col1, hv_RowProj, hv_ColProj, hv_Real, hv_Real1;
    HTuple hv_k, hv_b, hv_k1, hv_b1, hv_x, hv_y, hv_x0, hv_y0;
    HTuple hv_TargetRow, hv_TargetCol, hv_k2, hv_b2, hv_kIn;
    HTuple hv_bIn, hv_LineOutRow, hv_LineOutCol, hv_LineOutRow1;
    HTuple hv_LineOutCol1, hv_k3, hv_b3, hv_Sqrt;

    // Initialize local and output iconic variables 
    HOperatorSet.GenEmptyObj(out ho_Image11515282Cam0);

    ho_Image11515282Cam0.Dispose();
    HOperatorSet.ReadImage(out ho_Image11515282Cam0, "C:/项目/李博定位台需求/AssemblyBench/JPT TosaTest/bin/Debug/ImageSaved/ImageSaved/11月5日 15时28分2秒_Cam0.jpg");
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.CloseWindow(HDevWindowStack.Pop());
    }
    dev_open_window_fit_image(ho_Image11515282Cam0, 0, 0, -1, -1, out hv_WindowHandle);
    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.DispObj(ho_Image11515282Cam0, HDevWindowStack.GetActive());
    }
    hv_row = 456;
    hv_col = 789;

    hv_row1 = 1000;
    hv_col1 = 1450;
    HOperatorSet.ProjectionPl(200, 200, hv_row, hv_col, hv_row1, hv_col1, out hv_RowProj, 
        out hv_ColProj);
    HOperatorSet.DispCross(hv_WindowHandle, 200, 200, 26, 0);
    HOperatorSet.DispLine(hv_WindowHandle, hv_row, hv_col, hv_row1, hv_col1);
    HOperatorSet.DispCross(hv_WindowHandle, hv_RowProj, hv_ColProj, 26, 0);
    HOperatorSet.DispLine(hv_WindowHandle, 200, 200, hv_RowProj, hv_ColProj);
    HOperatorSet.TupleReal(hv_col1-hv_col, out hv_Real);
    HOperatorSet.TupleReal(hv_row1-hv_row, out hv_Real1);
    hv_k = hv_Real/hv_Real1;
    hv_b = hv_col1-(hv_k*hv_row1);

    HOperatorSet.DispCross(hv_WindowHandle, 234, (hv_k*234)+hv_b, 56, 0);

    //根据点画垂线
    hv_k1 = -1/hv_k;
    hv_b1 = ((234*hv_k)+hv_b)-((-1/hv_k)*234);



    hv_x = 234;
    hv_y = (234*hv_k1)+hv_b1;

    hv_x0 = 567;
    hv_y0 = (567*hv_k1)+hv_b1;
    HOperatorSet.DispCross(hv_WindowHandle, hv_x0, hv_y0, 56, 0);
    HOperatorSet.DispLine(hv_WindowHandle, hv_x, hv_y, hv_x0, hv_y0);

    //画指定长度的垂线
    GetVerticalFromDistance(hv_x, hv_y, hv_row, hv_col, hv_row1, hv_col1, 60, "row", 
        -1, out hv_TargetRow, out hv_TargetCol, out hv_k2, out hv_b2, out hv_kIn, 
        out hv_bIn);

    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetColor(HDevWindowStack.GetActive(), "blue");
    }
    HOperatorSet.DispCross(hv_WindowHandle, hv_TargetRow, hv_TargetCol, 56, 0);

    GetVerticalFromDistance(hv_x, hv_y, hv_row, hv_col, hv_row1, hv_col1, 60, "row", 
        1, out hv_TargetRow, out hv_TargetCol, out hv_k2, out hv_b2, out hv_kIn, 
        out hv_bIn);

    if (HDevWindowStack.IsOpen())
    {
      HOperatorSet.SetColor(HDevWindowStack.GetActive(), "blue");
    }
    HOperatorSet.DispCross(hv_WindowHandle, hv_TargetRow, hv_TargetCol, 56, 0);

    GetParallelLineFromDistance(hv_row, hv_col, hv_row1, hv_col1, 350, "row", -1, 
        out hv_LineOutRow, out hv_LineOutCol, out hv_LineOutRow1, out hv_LineOutCol1, 
        out hv_k3, out hv_b3);

    HOperatorSet.DispLine(hv_WindowHandle, hv_LineOutRow, hv_LineOutCol, hv_LineOutRow1, 
        hv_LineOutCol1);
    HOperatorSet.DispCross(hv_WindowHandle, hv_LineOutRow, hv_LineOutCol, 106, 0);
    HOperatorSet.DispCross(hv_WindowHandle, hv_LineOutRow1, hv_LineOutCol1, 106, 
        0);

    HOperatorSet.TupleSqrt(((hv_LineOutRow-hv_row)*(hv_LineOutRow-hv_row))+((hv_LineOutCol-hv_col)*(hv_LineOutCol-hv_col)), 
        out hv_Sqrt);













    ho_Image11515282Cam0.Dispose();

  }


}
#if !NO_EXPORT_APP_MAIN
public class HDevelopExportApp
{
  static void Main(string[] args)
  {
    new HDevelopExport();
  }
}
#endif

