<?xml version="1.0" encoding="UTF-8"?>
<hdevelop file_version="1.1" halcon_version="12.0">
<procedure name="main">
<interface/>
<body>
<c>*以下是测量实际尺寸</c>
<c>* Measure 01: Code generated by Measure 01</c>
<c>* Measure 01: Initialize calibration</c>
<l>read_cam_par ('C:/Code/Halcon/标定板进行相机标定/Param.cal', CameraParameters)</l>
<l>read_pose ('C:/Code/Halcon/标定板进行相机标定/CamPos.dat', CameraPose)</l>
<c>* Measure 01: Prepare measurement</c>
<l>AmplitudeThreshold := 30</l>
<l>RoiWidthLen2 := 4.5</l>
<l>set_system ('int_zooming', 'false')</l>
<c>* Measure 01: Coordinates for line Measure 01 [0]</c>
<l>LineRowStart_Measure_01_0 := 31.2229</l>
<l>LineColumnStart_Measure_01_0 := 417.486</l>
<l>LineRowEnd_Measure_01_0 := 1526.17</l>
<l>LineColumnEnd_Measure_01_0 := 97.1602</l>
<c>* Measure 01: Convert coordinates to rectangle2 type</c>
<l>TmpCtrl_Row := 0.5*(LineRowStart_Measure_01_0+LineRowEnd_Measure_01_0)</l>
<l>TmpCtrl_Column := 0.5*(LineColumnStart_Measure_01_0+LineColumnEnd_Measure_01_0)</l>
<l>TmpCtrl_Dr := LineRowStart_Measure_01_0-LineRowEnd_Measure_01_0</l>
<l>TmpCtrl_Dc := LineColumnEnd_Measure_01_0-LineColumnStart_Measure_01_0</l>
<l>TmpCtrl_Phi := atan2(TmpCtrl_Dr, TmpCtrl_Dc)</l>
<l>TmpCtrl_Len1 := 0.5*sqrt(TmpCtrl_Dr*TmpCtrl_Dr + TmpCtrl_Dc*TmpCtrl_Dc)</l>
<l>TmpCtrl_Len2 := RoiWidthLen2</l>
<c>* Measure 01: Create measure for line Measure 01 [0]</c>
<c>* Measure 01: Attention: This assumes all images have the same size!</c>
<l>gen_measure_rectangle2 (TmpCtrl_Row, TmpCtrl_Column, TmpCtrl_Phi, TmpCtrl_Len1, TmpCtrl_Len2, 3840, 2748, 'nearest_neighbor', MsrHandle_Measure_01_0)</l>
<c>* Measure 01: Coordinates for line Measure 01 [1]</c>
<l>LineRowStart_Measure_01_1 := 72.8821</l>
<l>LineColumnStart_Measure_01_1 := 211.43</l>
<l>LineRowEnd_Measure_01_1 := 348.452</l>
<l>LineColumnEnd_Measure_01_1 := 1878.48</l>
<c>* Measure 01: Convert coordinates to rectangle2 type</c>
<l>TmpCtrl_Row := 0.5*(LineRowStart_Measure_01_1+LineRowEnd_Measure_01_1)</l>
<l>TmpCtrl_Column := 0.5*(LineColumnStart_Measure_01_1+LineColumnEnd_Measure_01_1)</l>
<l>TmpCtrl_Dr := LineRowStart_Measure_01_1-LineRowEnd_Measure_01_1</l>
<l>TmpCtrl_Dc := LineColumnEnd_Measure_01_1-LineColumnStart_Measure_01_1</l>
<l>TmpCtrl_Phi := atan2(TmpCtrl_Dr, TmpCtrl_Dc)</l>
<l>TmpCtrl_Len1 := 0.5*sqrt(TmpCtrl_Dr*TmpCtrl_Dr + TmpCtrl_Dc*TmpCtrl_Dc)</l>
<l>TmpCtrl_Len2 := RoiWidthLen2</l>
<c>* Measure 01: Create measure for line Measure 01 [1]</c>
<c>* Measure 01: Attention: This assumes all images have the same size!</c>
<l>gen_measure_rectangle2 (TmpCtrl_Row, TmpCtrl_Column, TmpCtrl_Phi, TmpCtrl_Len1, TmpCtrl_Len2, 3840, 2748, 'nearest_neighbor', MsrHandle_Measure_01_1)</l>
<c>* Measure 01: Coordinates for line Measure 01 [2]</c>
<l>LineRowStart_Measure_01_2 := 281.474</l>
<l>LineColumnStart_Measure_01_2 := 1696.75</l>
<l>LineRowEnd_Measure_01_2 := 1764.09</l>
<l>LineColumnEnd_Measure_01_2 := 1405.81</l>
<c>* Measure 01: Convert coordinates to rectangle2 type</c>
<l>TmpCtrl_Row := 0.5*(LineRowStart_Measure_01_2+LineRowEnd_Measure_01_2)</l>
<l>TmpCtrl_Column := 0.5*(LineColumnStart_Measure_01_2+LineColumnEnd_Measure_01_2)</l>
<l>TmpCtrl_Dr := LineRowStart_Measure_01_2-LineRowEnd_Measure_01_2</l>
<l>TmpCtrl_Dc := LineColumnEnd_Measure_01_2-LineColumnStart_Measure_01_2</l>
<l>TmpCtrl_Phi := atan2(TmpCtrl_Dr, TmpCtrl_Dc)</l>
<l>TmpCtrl_Len1 := 0.5*sqrt(TmpCtrl_Dr*TmpCtrl_Dr + TmpCtrl_Dc*TmpCtrl_Dc)</l>
<l>TmpCtrl_Len2 := RoiWidthLen2</l>
<c>* Measure 01: Create measure for line Measure 01 [2]</c>
<c>* Measure 01: Attention: This assumes all images have the same size!</c>
<l>gen_measure_rectangle2 (TmpCtrl_Row, TmpCtrl_Column, TmpCtrl_Phi, TmpCtrl_Len1, TmpCtrl_Len2, 3840, 2748, 'nearest_neighbor', MsrHandle_Measure_01_2)</l>
<c>* Measure 01: Coordinates for line Measure 01 [3]</c>
<l>LineRowStart_Measure_01_3 := 1395.31</l>
<l>LineColumnStart_Measure_01_3 := 58.0961</l>
<l>LineRowEnd_Measure_01_3 := 1716.5</l>
<l>LineColumnEnd_Measure_01_3 := 1581.6</l>
<c>* Measure 01: Convert coordinates to rectangle2 type</c>
<l>TmpCtrl_Row := 0.5*(LineRowStart_Measure_01_3+LineRowEnd_Measure_01_3)</l>
<l>TmpCtrl_Column := 0.5*(LineColumnStart_Measure_01_3+LineColumnEnd_Measure_01_3)</l>
<l>TmpCtrl_Dr := LineRowStart_Measure_01_3-LineRowEnd_Measure_01_3</l>
<l>TmpCtrl_Dc := LineColumnEnd_Measure_01_3-LineColumnStart_Measure_01_3</l>
<l>TmpCtrl_Phi := atan2(TmpCtrl_Dr, TmpCtrl_Dc)</l>
<l>TmpCtrl_Len1 := 0.5*sqrt(TmpCtrl_Dr*TmpCtrl_Dr + TmpCtrl_Dc*TmpCtrl_Dc)</l>
<l>TmpCtrl_Len2 := RoiWidthLen2</l>
<c>* Measure 01: Create measure for line Measure 01 [3]</c>
<c>* Measure 01: Attention: This assumes all images have the same size!</c>
<l>gen_measure_rectangle2 (TmpCtrl_Row, TmpCtrl_Column, TmpCtrl_Phi, TmpCtrl_Len1, TmpCtrl_Len2, 3840, 2748, 'nearest_neighbor', MsrHandle_Measure_01_3)</l>
<c>* Measure 01: ***************************************************************</c>
<c>* Measure 01: * The code which follows is to be executed once / measurement *</c>
<c>* Measure 01: ***************************************************************</c>
<c>* Measure 01: Load image</c>
<l>read_image (Image, 'C:/Users/Administrator/Desktop/test/1.bmp')</l>
<c>* Measure 01: Execute measurements</c>
<l>measure_pos (Image, MsrHandle_Measure_01_0, 0.8, 30, 'all', 'all', Row_Measure_01_0, Column_Measure_01_0, Amplitude_Measure_01_0, Distance_Measure_01_0)</l>
<l>measure_pos (Image, MsrHandle_Measure_01_1, 0.8, 30, 'all', 'all', Row_Measure_01_1, Column_Measure_01_1, Amplitude_Measure_01_1, Distance_Measure_01_1)</l>
<l>measure_pos (Image, MsrHandle_Measure_01_2, 0.8, 30, 'all', 'all', Row_Measure_01_2, Column_Measure_01_2, Amplitude_Measure_01_2, Distance_Measure_01_2)</l>
<l>measure_pos (Image, MsrHandle_Measure_01_3, 0.8, 30, 'all', 'all', Row_Measure_01_3, Column_Measure_01_3, Amplitude_Measure_01_3, Distance_Measure_01_3)</l>
<c>* Measure 01: Transform to world coordinates</c>
<c>* Measure 01: Calibrate positions for Measure 01 [0]</c>
<l>image_points_to_world_plane (CameraParameters, CameraPose, Row_Measure_01_0, Column_Measure_01_0, 0.001, Column_World_Measure_01_0, Row_World_Measure_01_0)</l>
<c>* Measure 01: Calibrate distances</c>
<c></c>
<l>cam_par_pose_to_hom_mat3d(CameraParameters, CameraPose, HomMat3D)</l>
<l>hom_mat3d_invert(HomMat3D, HomMat3DInvert)</l>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<c></c>
<l>TmpCtrl_Length := |Row_World_Measure_01_0|</l>
<l>if (TmpCtrl_Length &gt; 0)</l>
<l>    tuple_select_range (Row_World_Measure_01_0, 0, TmpCtrl_Length - 2, TmpCtrl_RowFrom)</l>
<l>    tuple_select_range (Column_World_Measure_01_0, 0, TmpCtrl_Length - 2, TmpCtrl_ColumnFrom)</l>
<l>    tuple_select_range (Row_World_Measure_01_0, 1, TmpCtrl_Length - 1, TmpCtrl_RowTo)</l>
<l>    tuple_select_range (Column_World_Measure_01_0, 1, TmpCtrl_Length - 1, TmpCtrl_ColumnTo)</l>
<l>    distance_pp (TmpCtrl_RowFrom, TmpCtrl_ColumnFrom, TmpCtrl_RowTo, TmpCtrl_ColumnTo, Distance_World_Measure_01_0)</l>
<l>endif</l>
<c>* Measure 01: Calibrate positions for Measure 01 [1]</c>
<l>image_points_to_world_plane (CameraParameters, CameraPose, Row_Measure_01_1, Column_Measure_01_1, 0.001, Column_World_Measure_01_1, Row_World_Measure_01_1)</l>
<c>* Measure 01: Calibrate distances</c>
<l>TmpCtrl_Length := |Row_World_Measure_01_1|</l>
<l>if (TmpCtrl_Length &gt; 0)</l>
<l>    tuple_select_range (Row_World_Measure_01_1, 0, TmpCtrl_Length - 2, TmpCtrl_RowFrom)</l>
<l>    tuple_select_range (Column_World_Measure_01_1, 0, TmpCtrl_Length - 2, TmpCtrl_ColumnFrom)</l>
<l>    tuple_select_range (Row_World_Measure_01_1, 1, TmpCtrl_Length - 1, TmpCtrl_RowTo)</l>
<l>    tuple_select_range (Column_World_Measure_01_1, 1, TmpCtrl_Length - 1, TmpCtrl_ColumnTo)</l>
<l>    distance_pp (TmpCtrl_RowFrom, TmpCtrl_ColumnFrom, TmpCtrl_RowTo, TmpCtrl_ColumnTo, Distance_World_Measure_01_1)</l>
<l>endif</l>
<c>* Measure 01: Calibrate positions for Measure 01 [2]</c>
<l>image_points_to_world_plane (CameraParameters, CameraPose, Row_Measure_01_2, Column_Measure_01_2, 0.001, Column_World_Measure_01_2, Row_World_Measure_01_2)</l>
<c>* Measure 01: Calibrate distances</c>
<l>TmpCtrl_Length := |Row_World_Measure_01_2|</l>
<l>if (TmpCtrl_Length &gt; 0)</l>
<l>    tuple_select_range (Row_World_Measure_01_2, 0, TmpCtrl_Length - 2, TmpCtrl_RowFrom)</l>
<l>    tuple_select_range (Column_World_Measure_01_2, 0, TmpCtrl_Length - 2, TmpCtrl_ColumnFrom)</l>
<l>    tuple_select_range (Row_World_Measure_01_2, 1, TmpCtrl_Length - 1, TmpCtrl_RowTo)</l>
<l>    tuple_select_range (Column_World_Measure_01_2, 1, TmpCtrl_Length - 1, TmpCtrl_ColumnTo)</l>
<l>    distance_pp (TmpCtrl_RowFrom, TmpCtrl_ColumnFrom, TmpCtrl_RowTo, TmpCtrl_ColumnTo, Distance_World_Measure_01_2)</l>
<l>endif</l>
<c>* Measure 01: Calibrate positions for Measure 01 [3]</c>
<l>image_points_to_world_plane (CameraParameters, CameraPose, Row_Measure_01_3, Column_Measure_01_3, 0.001, Column_World_Measure_01_3, Row_World_Measure_01_3)</l>
<c>* Measure 01: Calibrate distances</c>
<l>TmpCtrl_Length := |Row_World_Measure_01_3|</l>
<l>if (TmpCtrl_Length &gt; 0)</l>
<l>    tuple_select_range (Row_World_Measure_01_3, 0, TmpCtrl_Length - 2, TmpCtrl_RowFrom)</l>
<l>    tuple_select_range (Column_World_Measure_01_3, 0, TmpCtrl_Length - 2, TmpCtrl_ColumnFrom)</l>
<l>    tuple_select_range (Row_World_Measure_01_3, 1, TmpCtrl_Length - 1, TmpCtrl_RowTo)</l>
<l>    tuple_select_range (Column_World_Measure_01_3, 1, TmpCtrl_Length - 1, TmpCtrl_ColumnTo)</l>
<l>    distance_pp (TmpCtrl_RowFrom, TmpCtrl_ColumnFrom, TmpCtrl_RowTo, TmpCtrl_ColumnTo, Distance_World_Measure_01_3)</l>
<l>endif</l>
<c>* Measure 01: Do something with the results</c>
<c>* Measure 01: Clear measure when done</c>
<l>close_measure (MsrHandle_Measure_01_0)</l>
<l>close_measure (MsrHandle_Measure_01_1)</l>
<l>close_measure (MsrHandle_Measure_01_2)</l>
<l>close_measure (MsrHandle_Measure_01_3)</l>
<c></c>
</body>
<docu id="main">
<parameters/>
</docu>
</procedure>
</hdevelop>
